# 3D Molecular Representations

Generate 3D molecular representations including voxel grids for 3D CNNs, point clouds for geometric deep learning, multi-view snapshots, and surface-based descriptors. These methods capture spatial information crucial for understanding molecular interactions and properties.

## Overview

3D molecular representations preserve spatial relationships that are critical for molecular recognition, binding affinity prediction, and understanding conformational effects. These methods bridge traditional molecular modeling with modern deep learning architectures.

::::{grid} 1 1 2 2
:gutter: 3

:::{grid-item-card} ðŸ“· **Multi-View Snapshots**
DeepSnap-style rotational 2D projections of 3D structures
:::

:::{grid-item-card} ðŸ§Š **Voxel Grids**
3D volumetric representations for 3D CNNs
:::

:::{grid-item-card} â˜ï¸ **Point Clouds**
Coordinate-based representations with atomic features
:::

:::{grid-item-card} ðŸŽ­ **Surface Descriptors**
Surface-based features for binding site analysis
:::
::::

## Available Featurizers

| Featurizer | Output Shape | Parameters | Description |
|------------|--------------|------------|-------------|
| `deepsnap_3d` | (256, 256, 3) | `rotation_angles`, `axis` | Multi-view 3D snapshots |
| `voxel_grid` | (48, 48, 48, 8) | `grid_size`, `resolution` | 3D voxel grids with chemical properties |
| `point_cloud_3d` | (100, 6) | `max_atoms`, `normalize_coords` | Point clouds with atom features |
| `pymol_3d_render` | (224, 224, 3) | `style`, `background` | High-quality PyMOL renderings |
| `surface_descriptors` | (1000, 8) | `probe_radius`, `n_surface_points` | Molecular surface descriptors |

## DeepSnap Multi-View Images

Generate multiple 2D projections of 3D molecular conformations by systematic rotation, capturing different structural perspectives for enhanced CNN learning.

```python
import polyglotmol as pm
import numpy as np

# Generate single view (default first rotation)
featurizer = pm.get_featurizer("deepsnap_3d")
snapshot = featurizer.featurize("CC(C)(C)C1CCC(C)(C)N1O")  # TEMPO radical
print(f"Snapshot shape: {snapshot.shape}")  # (256, 256, 3)
print(f"Image dtype: {snapshot.dtype}")  # uint8

# Generate all rotational views
all_snapshots = featurizer.featurize("CC(C)(C)C1CCC(C)(C)N1O", return_single=False)
print(f"Generated {len(all_snapshots)} rotational views")
print(f"Each view shape: {all_snapshots[0].shape}")
```

### Parameters

- `image_size`: Tuple (width, height), default (256, 256)
- `rotation_angles`: List of rotation angles in degrees, default [0, 45, 90, 135, 180, 225, 270, 315]
- `axis`: Rotation axis ("x", "y", "z"), default "z"

```python
# Custom rotation settings
featurizer_custom = pm.get_featurizer("deepsnap_3d", 
                                      rotation_angles=[0, 30, 60, 90, 120, 150],
                                      axis="y",
                                      image_size=(512, 512))
custom_snapshots = featurizer_custom.featurize("c1ccc2c(c1)[nH]c1ccccc12", return_single=False)  # carbazole
print(f"Custom snapshots: {len(custom_snapshots)} views at {custom_snapshots[0].shape}")

# Different axes for comprehensive coverage
axes_coverage = {}
for axis in ["x", "y", "z"]:
    axis_featurizer = pm.get_featurizer("deepsnap_3d", axis=axis, rotation_angles=[0, 90, 180, 270])
    axis_views = axis_featurizer.featurize("c1ccc2c(c1)[nH]c1ccccc12", return_single=False)
    axes_coverage[axis] = axis_views
    print(f"{axis.upper()}-axis rotation: {len(axis_views)} views")
```

### Visual Examples

DeepSnap3D generates multiple 2D projections from different rotation angles, providing comprehensive views of 3D molecular structure:

![DeepSnap Multi-view](/_static/images/representations/3d/deepsnap_multiview_aspirin.png)

*Multiple rotational views of aspirin showing different perspectives of the 3D molecular structure. Each view captures unique spatial features important for 3D-aware machine learning models.*

### Multi-View Analysis

```python
# Analyze multi-view diversity
def analyze_view_diversity(snapshots):
    """Analyze diversity across multiple views"""
    similarities = []
    
    for i in range(len(snapshots)):
        for j in range(i+1, len(snapshots)):
            # Simple pixel-wise similarity
            img1 = snapshots[i].astype(np.float32)
            img2 = snapshots[j].astype(np.float32)
            similarity = np.corrcoef(img1.flatten(), img2.flatten())[0, 1]
            similarities.append(similarity)
    
    return {
        'mean_similarity': np.mean(similarities),
        'min_similarity': np.min(similarities), 
        'max_similarity': np.max(similarities),
        'diversity_score': 1 - np.mean(similarities)
    }

# Test with complex 3D molecule
complex_mol = "CC1=CC2=C(C=C1)C(C)(C)C3=C2C=CC=C3"  # tetramethylbenzofluorene
featurizer = pm.get_featurizer("deepsnap_3d")
views = featurizer.featurize(complex_mol, return_single=False)
diversity = analyze_view_diversity(views)
print(f"View diversity analysis: {diversity}")
```

## Voxel Grid Representations

Create 3D volumetric representations suitable for 3D convolutional neural networks, encoding atomic properties in discrete voxels.

```python
# Generate 3D voxel grid
featurizer = pm.get_featurizer("voxel_grid")
voxels = featurizer.featurize("c1ccc(cc1)C(=O)O")  # benzoic acid
print(f"Voxel grid shape: {voxels.shape}")  # (48, 48, 48, 8)
print(f"Data type: {voxels.dtype}")  # float32
print(f"Non-zero voxels: {np.count_nonzero(voxels)}")
print(f"Occupancy rate: {np.count_nonzero(voxels) / voxels.size * 100:.2f}%")
```

### Voxel Channel Analysis

The voxel grid contains 8 channels encoding different atomic properties:

```python
# Analyze individual channels
channel_names = [
    "Atomic Density", "Atomic Number", "Hydrophobicity", 
    "H-Bond Donors", "H-Bond Acceptors", "Aromatic",
    "Formal Charge", "VdW Radius"
]

complex_mol = "CC1=CC=C(C=C1)C(=O)NC2=CC=C(C=C2)Cl"  # drug-like molecule
voxels = featurizer.featurize(complex_mol)

print("Channel Analysis:")
for i, name in enumerate(channel_names):
    channel = voxels[:, :, :, i]
    non_zero = np.count_nonzero(channel)
    mean_val = channel[channel > 0].mean() if non_zero > 0 else 0
    max_val = channel.max()
    print(f"  {name}: {non_zero} voxels, mean={mean_val:.3f}, max={max_val:.3f}")
```

### Parameters

- `grid_size`: Voxel grid dimension, default 48
- `resolution`: Voxel size in Angstroms, default 0.5
- `n_channels`: Number of property channels, default 8

```python
# High-resolution voxel grid
featurizer_hires = pm.get_featurizer("voxel_grid", 
                                     grid_size=64, 
                                     resolution=0.25)
hires_voxels = featurizer_hires.featurize("c1ccc(cc1)C(=O)O")
print(f"High-res voxels: {hires_voxels.shape}")  # (64, 64, 64, 8)

# Compact representation for small molecules
featurizer_compact = pm.get_featurizer("voxel_grid", 
                                       grid_size=24, 
                                       resolution=0.8)
compact_voxels = featurizer_compact.featurize("CCO")  # ethanol
print(f"Compact voxels: {compact_voxels.shape}")  # (24, 24, 24, 8)
```

### Visual Examples

The voxel grid represents molecular 3D structure as a multi-channel volumetric grid. Here we show 2D slices through the middle of the grid:

![Voxel Grid Slices](/_static/images/representations/3d/voxel_slices_aspirin.png)

*Eight channels of the voxel grid for aspirin, each encoding different atomic properties. The Z-slice through the middle shows how chemical features are spatially distributed in 3D space.*

### 3D CNN Integration

```python
# Example 3D CNN architecture for voxel data
import torch
import torch.nn as nn

class Molecular3DCNN(nn.Module):
    def __init__(self, input_channels=8, num_classes=2):
        super().__init__()
        self.features = nn.Sequential(
            # First 3D conv block
            nn.Conv3d(input_channels, 32, kernel_size=3, padding=1),
            nn.BatchNorm3d(32),
            nn.ReLU(),
            nn.MaxPool3d(2),
            
            # Second 3D conv block
            nn.Conv3d(32, 64, kernel_size=3, padding=1),
            nn.BatchNorm3d(64),
            nn.ReLU(),
            nn.MaxPool3d(2),
            
            # Global pooling
            nn.AdaptiveAvgPool3d(1)
        )
        
        self.classifier = nn.Sequential(
            nn.Linear(64, 128),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(128, num_classes)
        )
    
    def forward(self, x):
        x = self.features(x)
        x = x.view(x.size(0), -1)
        return self.classifier(x)

# Test with voxel data
model = Molecular3DCNN()
print(f"3D CNN model parameters: {sum(p.numel() for p in model.parameters())}")

# Prepare voxel data for PyTorch (batch, channels, depth, height, width)
test_voxels = featurizer.featurize(["CCO", "CCN"])
X = np.array(test_voxels)
X_tensor = torch.FloatTensor(X.transpose(0, 4, 1, 2, 3))  # BCDHW format
print(f"Voxel tensor shape: {X_tensor.shape}")  # (2, 8, 48, 48, 48)
```

## Point Cloud Representations

Generate point cloud representations where each atom becomes a 3D point with associated features, suitable for geometric deep learning models.

```python
# Generate point cloud
featurizer = pm.get_featurizer("point_cloud_3d")
points = featurizer.featurize("CCN(CC)CC")  # triethylamine
print(f"Point cloud shape: {points.shape}")  # (100, 6)
print(f"Data type: {points.dtype}")  # float32

# Examine point features
coords = points[:, :3]  # XYZ coordinates
atomic_nums = points[:, 3]  # Atomic numbers
charges = points[:, 4]  # Partial charges  
radii = points[:, 5]  # Van der Waals radii

print(f"Coordinate range: X[{coords[:, 0].min():.2f}, {coords[:, 0].max():.2f}]")
print(f"Atomic numbers: {np.unique(atomic_nums[atomic_nums > 0])}")
print(f"Charge range: [{charges.min():.3f}, {charges.max():.3f}]")
```

### Point Cloud Analysis

```python
# Analyze point cloud properties
def analyze_point_cloud(points):
    """Analyze point cloud structure"""
    # Find actual atoms (non-padded points)
    real_atoms = points[points[:, 3] > 0]  # Non-zero atomic numbers
    
    if len(real_atoms) == 0:
        return {"n_atoms": 0}
    
    coords = real_atoms[:, :3]
    
    # Geometric properties
    centroid = coords.mean(axis=0)
    distances_from_center = np.linalg.norm(coords - centroid, axis=1)
    pairwise_distances = []
    
    for i in range(len(coords)):
        for j in range(i+1, len(coords)):
            dist = np.linalg.norm(coords[i] - coords[j])
            pairwise_distances.append(dist)
    
    return {
        "n_atoms": len(real_atoms),
        "centroid": centroid,
        "mean_distance_from_center": distances_from_center.mean(),
        "molecular_radius": distances_from_center.max(),
        "mean_pairwise_distance": np.mean(pairwise_distances) if pairwise_distances else 0,
        "min_pairwise_distance": np.min(pairwise_distances) if pairwise_distances else 0,
        "max_pairwise_distance": np.max(pairwise_distances) if pairwise_distances else 0
    }

# Analyze different molecules
test_molecules = ["CCO", "c1ccccc1", "CC(C)(C)C", "CC1=CC=CC=C1"]
for mol in test_molecules:
    points = featurizer.featurize(mol)
    analysis = analyze_point_cloud(points)
    print(f"{mol}: {analysis['n_atoms']} atoms, radius={analysis['molecular_radius']:.2f}Ã…")
```

### Parameters

- `max_atoms`: Maximum number of atoms (padding applied), default 100
- `normalize_coords`: Normalize coordinates to unit sphere, default True

```python
# Large molecules with more atoms
featurizer_large = pm.get_featurizer("point_cloud_3d", 
                                     max_atoms=200, 
                                     normalize_coords=False)
large_points = featurizer_large.featurize("CC1=CC=C(C=C1)C(=O)NC2=CC=C(C=C2)Cl")
print(f"Large molecule point cloud: {large_points.shape}")  # (200, 6)

# Keep original coordinates (no normalization)
analysis_unnorm = analyze_point_cloud(large_points)
print(f"Unnormalized coordinates - radius: {analysis_unnorm['molecular_radius']:.2f}Ã…")
```

### Visual Examples

Point clouds represent molecules as 3D coordinates with atomic features, suitable for geometric deep learning:

![Point Cloud 3D](/_static/images/representations/3d/pointcloud_3d_aspirin.png)

*3D point cloud visualization of aspirin where each point represents an atom. Points are colored by atomic number, showing the spatial distribution of different elements (carbon, oxygen, hydrogen) in 3D space.*

### PointNet Integration

```python
# Example PointNet-style architecture for point clouds
class MolecularPointNet(nn.Module):
    def __init__(self, num_points=100, num_features=6, num_classes=2):
        super().__init__()
        
        # Point-wise MLPs
        self.point_mlp = nn.Sequential(
            nn.Conv1d(num_features, 64, 1),
            nn.BatchNorm1d(64),
            nn.ReLU(),
            nn.Conv1d(64, 128, 1),
            nn.BatchNorm1d(128),
            nn.ReLU(),
            nn.Conv1d(128, 256, 1),
            nn.BatchNorm1d(256),
            nn.ReLU()
        )
        
        # Global feature aggregation
        self.global_mlp = nn.Sequential(
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(128, num_classes)
        )
    
    def forward(self, x):
        # x shape: (batch, num_points, num_features)
        x = x.transpose(1, 2)  # (batch, num_features, num_points)
        x = self.point_mlp(x)  # (batch, 256, num_points)
        x = torch.max(x, 2)[0]  # Global max pooling -> (batch, 256)
        x = self.global_mlp(x)
        return x

# Test with point cloud data
pointnet = MolecularPointNet()
print(f"PointNet parameters: {sum(p.numel() for p in pointnet.parameters())}")

# Prepare point cloud data
test_points = featurizer.featurize(["CCO", "CCN"])
X_points = torch.FloatTensor(test_points)
print(f"Point cloud tensor: {X_points.shape}")  # (2, 100, 6)
```

## High-Quality 3D Rendering

Generate publication-quality 3D molecular renderings using PyMOL for visualization and presentation.

:::{note}
Requires PyMOL: `conda install -c conda-forge pymol-open-source`
:::

```python
# Basic PyMOL rendering
featurizer = pm.get_featurizer("pymol_3d_render")
render = featurizer.featurize("c1ccc2c(c1)[nH]c1ccccc12")  # carbazole
print(f"PyMOL render shape: {render.shape}")  # (224, 224, 3)
print(f"Render dtype: {render.dtype}")  # uint8

# Different rendering styles
styles = ["stick", "ball_and_stick", "surface"]
molecule = "c1ccc(cc1)C(=O)O"  # benzoic acid

for style in styles:
    style_featurizer = pm.get_featurizer("pymol_3d_render", style=style)
    styled_render = style_featurizer.featurize(molecule)
    print(f"{style.title()} style: {styled_render.shape}")
```

### Parameters

- `image_size`: Tuple (width, height), default (224, 224)
- `style`: Rendering style ("stick", "ball_and_stick", "surface")
- `background`: Background color, default "white"

```python
# Custom rendering settings
featurizer_custom = pm.get_featurizer("pymol_3d_render",
                                      image_size=(512, 512),
                                      style="ball_and_stick",
                                      background="black")
custom_render = featurizer_custom.featurize("CC1=CC=CC=C1")  # toluene
print(f"Custom PyMOL render: {custom_render.shape}")

# High-resolution rendering for publications
featurizer_hires = pm.get_featurizer("pymol_3d_render",
                                     image_size=(1024, 1024),
                                     style="stick")
hires_render = featurizer_hires.featurize("c1ccc2c(c1)[nH]c1ccccc12")
print(f"Publication-quality render: {hires_render.shape}")
```

## Molecular Surface Representations

Generate surface-based descriptors capturing molecular topology and chemical properties important for binding interactions.

```python
# Generate surface descriptors
featurizer = pm.get_featurizer("surface_descriptors")
surface = featurizer.featurize("c1ccc(cc1)C(=O)N(C)C")  # N,N-dimethylbenzamide
print(f"Surface shape: {surface.shape}")  # (1000, 8)
print(f"Surface dtype: {surface.dtype}")  # float32

# Analyze surface properties
surface_coords = surface[:, :3]  # XYZ coordinates of surface points
surface_props = surface[:, 3:]   # Surface properties

print(f"Surface points: {len(surface_coords)}")
print(f"Surface span: X[{surface_coords[:, 0].min():.2f}, {surface_coords[:, 0].max():.2f}]Ã…")

# Property analysis
prop_names = ["Curvature", "Hydrophobicity", "H-Donors", "H-Acceptors", "Electrostatic"]
for i, name in enumerate(prop_names):
    prop_values = surface_props[:, i]
    non_zero = np.count_nonzero(prop_values)
    if non_zero > 0:
        print(f"{name}: {non_zero} points, mean={prop_values[prop_values != 0].mean():.3f}")
```

### Parameters

- `probe_radius`: Solvent probe radius in Angstroms, default 1.4
- `n_surface_points`: Number of surface points to sample, default 1000

```python
# High-density surface sampling
featurizer_dense = pm.get_featurizer("surface_descriptors",
                                     probe_radius=1.0,  # Smaller probe
                                     n_surface_points=2000)
dense_surface = featurizer_dense.featurize("CC1=CC=C(C=C1)C(=O)NC2=CC=C(C=C2)Cl")
print(f"Dense surface: {dense_surface.shape}")  # (2000, 8)

# Analyze surface diversity across molecules
def surface_diversity_analysis(molecules):
    """Compare surface properties across molecules"""
    featurizer = pm.get_featurizer("surface_descriptors")
    
    for mol in molecules:
        surface = featurizer.featurize(mol)
        real_points = surface[surface[:, 3] > 0]  # Non-zero curvature points
        
        if len(real_points) > 0:
            avg_curvature = real_points[:, 3].mean()
            hydrophobic_fraction = (real_points[:, 4] > 0).mean()
            polar_fraction = (real_points[:, 5] > 0).mean() + (real_points[:, 6] > 0).mean()
            
            print(f"{mol}: {len(real_points)} surface points")
            print(f"  Curvature: {avg_curvature:.3f}")
            print(f"  Hydrophobic: {hydrophobic_fraction:.3f}")
            print(f"  Polar: {polar_fraction:.3f}")

# Compare different molecular types
diverse_molecules = ["CCO", "c1ccccc1", "CC(=O)O", "CCN(CC)CC"]
surface_diversity_analysis(diverse_molecules)
```

## Batch Processing and Integration

```python
# Efficient 3D processing
molecules = ["CCO", "CCN", "CCC", "c1ccccc1"] * 50  # 200 molecules

# Parallel voxel generation
voxel_featurizer = pm.get_featurizer("voxel_grid")
voxels = voxel_featurizer.featurize(molecules, n_workers=4)
print(f"Generated {len(voxels)} voxel grids")

# Memory-efficient 3D processing
def process_3d_batch(molecules, representation="voxel_grid", batch_size=50):
    """Process 3D representations in batches"""
    featurizer = pm.get_featurizer(representation)
    results = []
    
    for i in range(0, len(molecules), batch_size):
        batch = molecules[i:i+batch_size]
        batch_results = featurizer.featurize(batch, n_workers=2)
        results.extend(batch_results)
        print(f"Processed {min(i+batch_size, len(molecules))}/{len(molecules)} molecules")
    
    return results

# Process with different 3D representations
point_clouds = process_3d_batch(molecules[:20], "point_cloud_3d")
snapshots = process_3d_batch(molecules[:10], "deepsnap_3d")
```

### Dataset Integration

```python
from polyglotmol.data import MolecularDataset, Molecule

# Create 3D-enhanced dataset
molecules = [Molecule(smi) for smi in ["CCO", "CCN", "CCC", "c1ccccc1"]]
dataset = MolecularDataset(molecules)

# Add multiple 3D representations
dataset.add_features("voxel_grid")         # (48, 48, 48, 8)
dataset.add_features("point_cloud_3d")     # (100, 6)
dataset.add_features("deepsnap_3d")        # (256, 256, 3)

print(f"3D dataset: {len(dataset)} molecules")
print(f"Available 3D features: {list(dataset.features.columns)}")

# Access 3D features
voxel_data = dataset.features["voxel_grid"]
point_data = dataset.features["point_cloud_3d"]
print(f"Voxel data shape: {voxel_data.iloc[0].shape}")
print(f"Point data shape: {point_data.iloc[0].shape}")
```

### 3D Visualization

```python
# Visualize 3D representations
def visualize_voxel_occupancy(voxels, threshold=0.1):
    """Analyze voxel grid occupancy"""
    occupancy = (voxels.sum(axis=-1) > threshold).astype(int)
    
    stats = {
        'total_voxels': voxels.size // voxels.shape[-1],
        'occupied_voxels': occupancy.sum(),
        'occupancy_rate': occupancy.sum() / occupancy.size,
        'center_of_mass': [
            np.average(np.arange(voxels.shape[0]), weights=occupancy.sum(axis=(1,2))),
            np.average(np.arange(voxels.shape[1]), weights=occupancy.sum(axis=(0,2))),  
            np.average(np.arange(voxels.shape[2]), weights=occupancy.sum(axis=(0,1)))
        ]
    }
    
    return stats

# Analyze voxel occupancy for different molecules
test_molecules = ["CCO", "c1ccccc1", "CC1=CC=CC=C1"]
featurizer = pm.get_featurizer("voxel_grid")

for mol in test_molecules:
    voxels = featurizer.featurize(mol)
    stats = visualize_voxel_occupancy(voxels)
    print(f"{mol}: {stats['occupied_voxels']} occupied voxels ({stats['occupancy_rate']:.3f})")
    print(f"  Center of mass: ({stats['center_of_mass'][0]:.1f}, {stats['center_of_mass'][1]:.1f}, {stats['center_of_mass'][2]:.1f})")
```

## References

- **DeepSnap**: Uesawa, Y. "Quantitative structure-activity relationship analysis using deep learning based on a novel molecular image input technique." *Bioorg Med Chem Lett 2018*
- **AtomNet**: Wallach, I., et al. "AtomNet: a deep convolutional neural network for bioactivity prediction in structure-based drug discovery." *arXiv 2015*
- **PointNet**: Qi, C.R., et al. "PointNet: Deep learning on point sets for 3D classification and segmentation." *CVPR 2017*
- **PyMOL**: https://pymol.org/2/
- **MaSIF**: Gainza, P., et al. "Deciphering interaction fingerprints from protein molecular surfaces using geometric deep learning." *Nature Methods 2020*